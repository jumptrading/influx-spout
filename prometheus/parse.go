// Copyright 2018 Jump Trading
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package prometheus

import (
	"bytes"
	"errors"
	"fmt"

	"github.com/jumptrading/influx-spout/convert"
)

// ParseMetrics parses multiple Prometheus metric lines, returning a
// MetricSet.
func ParseMetrics(s []byte) (*MetricSet, error) {
	set := NewMetricSet()
	for i, line := range bytes.Split(s, []byte("\n")) {
		if len(line) == 0 {
			continue
		}
		m, err := ParseMetric(line)
		if err != nil {
			return nil, fmt.Errorf("line %d: %v", i+1, err)
		}
		set.Update(m)
	}
	return set, nil
}

// ParseMetric parses a single Prometheus metric line.
//
// Note: The implementation currently only supports integer values and
// also doesn't handle escaped characters nor multiple sequential
// whitespace characters. This is OK for now because this only needs
// to support metrics generated by the various influx-spout
// components.
func ParseMetric(s []byte) (*Metric, error) {
	if len(s) < 3 {
		return nil, errors.New("invalid metric")
	}

	out := new(Metric)
	var err error

	i := bytes.IndexAny(s, " {")
	if i == -1 {
		return nil, errors.New("no value")
	}
	out.Name = s[:i]

	if s[i] == '{' {
		i++
		labels, n, err := parseLabels(s[i:])
		if err != nil {
			return nil, err
		}
		out.Labels = labels
		i += n
	}

	i++
	j := bytes.IndexByte(s[i:], ' ')
	if j == -1 {
		j = len(s[i:]) // No timestamp
	}
	out.Value, err = convert.ToInt(s[i : i+j])
	if err != nil {
		return nil, errors.New("invalid value")
	}

	i += j
	if i < len(s) {
		out.Milliseconds, err = convert.ToInt(s[i+1:])
		if err != nil {
			return nil, errors.New("invalid timestamp")
		}
	}

	return out, nil
}

func parseLabels(s []byte) (Labels, int, error) {
	if s[0] == '}' {
		return nil, 1, nil
	}

	i := 0
	out := make(Labels, 0, 1)
	for {
		var label Label

		j := bytes.Index(s[i:], []byte(`="`))
		if j == -1 {
			return nil, i, errors.New("invalid label")
		}
		label.Name = s[i : i+j]
		i = i + j + 2

		j = bytes.IndexByte(s[i:], '"')
		if j == -1 {
			return nil, i, errors.New("missing label closing quote")
		}
		label.Value = s[i : i+j]
		i = i + j + 1

		out = append(out, label)

		switch s[i] {
		case '}':
			return out, i + 1, nil
		case ',':
			i++
		default:
			return nil, i, errors.New("invalid label separator")
		}
	}
}
